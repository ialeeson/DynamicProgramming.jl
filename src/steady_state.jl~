### Problem
@kwdef @concrete struct SteadyState
    model_prob
    prob
    u0
    maxiters = 10^2
    abstol = 1e-10
    kwargs = (; )
    solver = Iterative(Î»)
end

### Cache
@kwdef @concrete struct SteadyStateCache
    prob
    aggregates = copy(prob.u0)
    model_cache = init(prob.model_prob)
    values = ntuple(i->model_cache.cache[i].values, length(model_cache.cache))
    distribution = zeros(length.((model_cache.prob.grid...,)))
    cache = ntuple(length(prob.prob)) do i
        (; grid, parameters) = model_cache.prob
        (; policies) = model_cache
        init(prob.prob[i]; grid=(grid...,), parameters,
            policies, distribution, aggregates)
    end
end
init(prob::SteadyState; kwargs...) = SteadyStateCache(; prob)

function (ss::SteadyStateCache)(du,u)
    for (i,cache) in enumerate(ss.model_cache.cache)
        copyto!.(cache.values, ss.values[i])
    end
    ss.model_cache.prob.parameters(u)
    solve!(ss.model_cache; skipinit=true)
    ss.model_cache
    for (i,cache) in enumerate(ss.model_cache.cache)
        copyto!.(ss.values[i], cache.values)
    end
    for cache in ss.cache
        solve!(cache)
    end
    grid = (ss.model_cache.prob.grid...,)
    inds = Index.(length.(grid))
    for i in 1:length(u)
        du[i] = sum(*(
            itensor(ss.distribution, inds),
            itensor(collect(grid[i]), inds[i])
        )) - u[i]
    end
end

function solve!(cache::SteadyStateCache; maxiters=cache.prob.maxiters, abstol=cache.prob.abstol)
    @printf "\nSteady State:\n"
    fill!(cache.distribution, inv(prod(size(cache.distribution))))
    copyto!(cache.aggregates, cache.prob.u0)
    cache.model_cache.prob.parameters(cache.aggregates)

    solve!(cache, cache.aggregates, cache.prob.solver; verbose=true, maxiters, abstol, cache.prob.kwargs...)

    cache
end
