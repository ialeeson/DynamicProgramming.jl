function (cache::Union{ValueFunctionCache{S,N,M,F}, EulerEquationCache{S,M,N,F}})(du,u,i) where {S,N,M,F}
    _interpolate!(cache.itp[i], reshape(u,length.(cache.grid)))
    chunks = Iterators.partition(
        1:prod(length.(cache.grid)),
        div(prod(length.(cache.grid)), Threads.nthreads())
    )
    tasks = map(chunks) do chunk
        Threads.@spawn howard_step!(cache, reshape(du,length.(cache.grid)), i, chunk)
    end
    sum(fetch.(tasks))
end

function howard_step!(cache::Union{ValueFunctionCache{S,N,M,F}, EulerEquationCache{S,M,N,F}}, values, j, chunk) where {S,N,M,F}
    
    (; prob, grid, policies, parameters, itp) = cache
    resid = 0.0
    for cidx in CartesianIndices(ntuple(i->length(grid[i]), S))[chunk]
        state = ntuple(i -> grid[i][cidx[i]], S)
        u = SVector{N,F}(ntuple(i -> policies[i][cidx], N))
        v = prob.f[j].f(itp, u, state, parameters)
        resid += abs2(values[cidx] - v[j])
        values[cidx] = v[j]
    end
    resid
end
