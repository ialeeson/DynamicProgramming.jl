### Iterative
@kwdef struct Iteration{F}
    λ::F = 1.0
end
@concrete struct IterationSolution
    u
    nsteps
    resid
end
function solve!(f::T, u0, i, solver::Iteration; maxiters, abstol, kwargs...) where {T<:ModelCache}
    g = Fix{3}(f,i)
    resid, u1 = (Inf, copy(u0))
    for i in 1:maxiters
        resid = g(u0,u1)
        resid < abstol && return IterationSolution(u0, i, resid)
    end
end
solve!(f::T, u0, i, solver; kwargs...) where {T<:ModelCache} =
    solve!(Fix{3}(f,i), u0, solver; kwargs...)

solve!(f::T, u0, i, alg::Missing; kwargs...) where {T<:ModelCache} = ()

function solve!(f, u0, alg::Iteration; verbose=false, maxiters, abstol, kwargs...)
    resid, du = (Inf, copy(u0))
    steps = 0
    for i in 1:maxiters
        f(du,u0)
        u0 .+=  alg.λ .* du
        resid = sum(abs.(du))
        resid < abstol && return IterationSolution(u0, i, resid)
        verbose && mod(steps,5) == 0 && begin
            @printf "\n%d Steps; " steps
            @printf "Err: %e\n" resid
            @info f
        end
        steps += 1
    end
    IterationSolution(u0, steps, resid)
end

function solve!(f, u0, alg::NonlinearSolveBase.AbstractNonlinearSolveAlgorithm; kwargs...)

    prob = NonlinearProblem{true}(u0,()) do du,u,p
        f(du,u)
    end
    sol = solve(prob, alg)
    u0 .= sol.u
end
solve(p::NonlinearProblem{true}, alg::Iteration; kwargs...) =
    solve(p.f, p.u0, alg; kwargs...)
solve(p::SteadyState, alg::Iteration; kwargs...) =
    solve(p, p.aggregates, alg; kwargs...)

