struct ValueFunctionProblem
end

struct ValueFunctionCache
end

struct ValueFunctionSolution
end

function CommonSolve.solve(cache::ValueFunctionCache, alg::Iteration;
    maxiters=10^2, abstol=nothing, verbose::Bool=true)

    for steps in 1:maxiters
        f = Fix{3}(f, parameters)
        step!(f,u2,u1,s,v)
        interpolate!(itp,v)
    end
    build_solution()
    
end

function inner_solve!(solver::T, f::F, g::H, u, v, state) where {T<:BracketingNonlinearSolve.AbstractBracketingAlgorithm,F}
    cidx = state.cidx
    u0 = ntuple(i->policies[cidx], length(policies))
    lb = lower(minimum.(grid), s, parameters)
    ub = upper(maximum.(grid), s, parameters)
    prob = NonlinearProblem{false}((lb,ub),p) do u,p
        f(u,s,v,p)
    end
    sol = solve(prob, solver)
end

function inner_solve!(solver::Optim.UnivariateOptimizer, f::F, s, v, p; lb, ub, kwargs...) where F
    Fix{3}(Fix{4}(f,P),u)
    sol = optimize(lb[1], ub[1], solver) do u
        v = ntuple(i-> values[i](u..., cidx[1]...), length(values))
        -f(v,u,s,p)
    end
    (; u=sol.minimizer, v=-sol.minimum)
end

function step!(cache::ValueFunctionCache, values, policies, chunk)
    (; solver, policies, values) = cache
    for cidx in chunk
        state = State(ntuple(i->grid[cidx[i]], length(cidx)), cidx)
        f = Fix{3}(Fix{4}(cache.f, parameters), values)
        inner_solve!(solver, f, policies, values, state)
    end
end

function step!(cache::HowardPolicyCache, values, chunk)
    (; solver, policies, itp) = cache
    for cidx in chunk
        state = State(ntuple(i->grid[cidx[i]], length(cidx)), cidx)
        u = ntuple(i->policies[i][cidx], length(policies))
        for j in 1:length(f)
            values[j][cidx] = f[j](u, state, itp, parameters)
        end
    end
end

function step!(cache::EulerEquationCache, values, policies, chunk)
    (; solver, policies, values) = cache
    for cidx in chunk
        state = State(ntuple(i->grid[cidx[i]], length(cidx)), cidx)
        ee = Fix{3}(Fix{4}(cache.ee, parameters), values)
        f = Fix{3}(Fix{4}(cache.f, parameters), values)
        inner_solve!(solver, ee, f, policies, values, state)
    end
end

V(v,u,s,p) = utility(u,s,p) + p.Î²*v[1]
